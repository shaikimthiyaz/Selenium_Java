Exceptions in Java ‚Äî In-Depth Story Explanation

The Story: A Test Automation Run at 2 AM 

You are running a nightly regression suite with:

500 UI tests

200 API tests

Parallel execution

Suddenly:

Browser crashes

Element not found

Network timeout

NullPointerException

üëâ If your framework does not handle exceptions properly, the entire run fails and gives no useful information.

This is why exceptions exist ‚Äî to handle unexpected situations gracefully.

## What Is an Exception?

An exception is an unwanted or unexpected event that disrupts the normal flow of a program.

In simple words:

Something went wrong while the program was running.

## Exception hierarchy in Java 

At the top:

**Throwable** (root of all errors/exceptions)

Under it:

**Error**

Serious problems, **usually from JVM**: OutOfMemoryError, StackOverflowError

You normally don‚Äôt catch or handle these in application/test code

**Exception**

Things your program might reasonably handle: IOException, SQLException, etc.

Inside Exception, two big categories:

**Checked** exceptions ‚Üí must be declared or handled

**Unchecked** exceptions ‚Üí RuntimeException and its subclasses


Throwable
 ‚îú‚îÄ‚îÄ Error
 ‚îî‚îÄ‚îÄ Exception
     ‚îú‚îÄ‚îÄ Checked Exception
     ‚îî‚îÄ‚îÄ Unchecked Exception



##  Checked Exceptions ‚úî (Compile-Time)

Exceptions checked at compile time.

Examples:

IOException

SQLException

FileNotFoundException

Example:
FileReader fr = new FileReader("data.txt");


‚ùå Compiler error unless handled.

Must be:

Caught OR

**Declared using throws**

##  Unchecked Exceptions  (Runtime)

Exceptions that occur during execution.

Examples:

NullPointerException

NoSuchElementException

ArithmeticException

Example:
String s = null;
s.length(); // NullPointerException


‚úî Compiler allows it
‚ùå Fails at runtime

## Exception Handling Keywords

**try-catch**

Whenever you expect something might go wrong and want to handle it gracefully, you use try-catch.

```
try {
    driver.findElement(By.id("login")).click();
} catch (NoSuchElementException e) {
    System.out.println("Login button not found");
}
```


‚úî Test does not crash
‚úî Meaningful message logged

## finally Block

finally runs no matter what (except JVM crash):

If no exception ‚Üí runs

If exception caught ‚Üí runs

If exception not caught ‚Üí runs, then exception propagates

Code that always runs ‚Äî exception or not.

Example:
```
try {
    driver.get(url);
} finally {
    driver.quit();
}
```

‚úî Browser always closes
‚úî Prevents resource leaks

## throw vs throws

`throw` :Used to explicitly throw an exception.

**eg:** throw new IllegalArgumentException("Invalid data");

`throws` : Used to declare exception.

**eg:** void readFile() throws IOException {}

## Custom Exceptions (Framework Design)

Why Custom Exceptions?

Generic exceptions are confusing.

‚ùå NullPointerException
‚úî TestDataNotFoundException

Custom Exception Example
```
class TestDataNotFoundException extends RuntimeException {
    TestDataNotFoundException(String msg) {
        super(msg);
    }
}
```

## Exception Handling in Automation Frameworks

Good Framework Behavior

‚úî Capture screenshot
‚úî Log error
‚úî Continue next test
‚úî Clean up resources


### 1. What is an exception?

An unexpected runtime event that disrupts program flow.

### 2. Difference between Error and Exception?

Errors are JVM-level and unrecoverable; exceptions are application-level and recoverable.


### 3. Difference between throw and throws?

Throw ‚Üí explicitly throws
Throws ‚Üí declares exception

### 4. How do you handle Selenium exceptions?

Retry

Wait

Screenshot

Log failure
