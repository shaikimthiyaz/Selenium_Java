### 1: Difference between ArrayList and LinkedList?

ArrayList: Backed by array, fast random access, slow insertion in middle.
LinkedList: Backed by nodes, fast insertion/removal, slow random access.

### 2: How does ArrayList grow internally?

Default capacity = 10.
When full, grows by 50% (new capacity = old + old/2).

### 3. How to make a List thread-safe?

Collections.synchronizedList(new ArrayList<>());

 or CopyOnWriteArrayList.

 # Remove duplicates from list

 ```
package DemoCollections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class RemoveDuplicatesFromList {

	public static void main(String[] args) {
		//Logic1 traditional method
		
		List<Integer> list = Arrays.asList(10,21,10,40,40,21,50,30);
		List<Integer> UniqueList = new ArrayList<>();
		for(Integer i:list) {
			if(!UniqueList.contains(i))
			{
				UniqueList.add(i);
			}
		}
		System.out.println("using traditional method list is :" + UniqueList);
		
		
		//logic 2 using set
		
		Set<Integer> set = new LinkedHashSet<>(list);
		System.out.println("Using linkendhashset :"+ set);
		
		
		//logic 3 using streams
		list =list.stream().distinct().collect(Collectors.toList());
		System.out.println("using streams list is :"+ list);
	}

}
```


**output:**

using traditional method list is :[10, 21, 40, 50, 30]
Using linkendhashset :[10, 21, 40, 50, 30]
using streams list is :[10, 21, 40, 50, 30]

# Reverse a list

```
package DemoCollections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ReverseList {

	public static void main(String[] args) {
// logic 1 **using for loop**
		List<Integer> ls = Arrays.asList(10,98,4,76,54);
		ArrayList<Integer> reverseList = new ArrayList<>();
		for(int i= ls.size()-1;i>=0;i--) {
			reverseList.add(ls.get(i));
			
		}
		System.out.print("reversed list using for loop is "+ reverseList);
		
//		logic 2 using collections **reverse method**
		
		Collections.reverse(ls);
		System.out.println("reverse list using reverse method "+ ls);
	}

}
```

**output:**

reversed list using for loop is [54, 76, 4, 98, 10]

reverse list using reverse method [54, 76, 4, 98, 10]

# sort in ascending order

```
import java.util.*;

public class SortList {
    public static void main(String[] args) {

        List<Integer> numbers = new ArrayList<>(Arrays.asList(40, 10, 30, 20));

        Collections.sort(numbers);

        System.out.println("Sorted List: " + numbers);
    }
}
```

**output:**  Sorted List: [10, 20, 30, 40]

# Sorting in Descending Order

```
import java.util.*;

public class SortDescending {
    public static void main(String[] args) {

        List<Integer> numbers = new ArrayList<>(Arrays.asList(40, 10, 30, 20));

        Collections.sort(numbers, Collections.reverseOrder());

        System.out.println("Descending Order: " + numbers);
    }
}
```

**output**:[40,30,20,10]

# second largest element in list

```
List<Integer> list = Arrays.asList(10, 40, 30, 20);

Collections.sort(list);

int secondLargest = list.get(list.size() - 2);

System.out.println(secondLargest);
```
# convert list to array

```
List<String> list = new ArrayList<>();
list.add("Chrome");
list.add("Firefox");

String[] array = list.toArray(new String[0]);
```

# Count Occurrence of Elements Using List

```
package DemoCollections;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class CountOccurenceofElementsInList {

	public static void main(String[] args) {
//logic1
        List<String> list = Arrays.asList("Login", "Signup", "Login", "Checkout", "Login");
        Map<String,Integer> countMap = new HashMap<>();
        for(String s:list) {
        	countMap.put(s, countMap.getOrDefault(s, 0)+1);
        }
        System.out.println("Count of each element is :"+ countMap);
        
        //logic 2
        Map<Object, Long> map = list.stream().collect(Collectors.groupingBy(e-> e, Collectors.counting()));
        System.out.println("using streams count is : "+ map);
	}	

}
```

**output:** 
Count of each element is :{Signup=1, Checkout=1, Login=3}
using streams count is : {Signup=1, Checkout=1, Login=3}


