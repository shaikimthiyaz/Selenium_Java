
# Real-Time Example in Selenium Java

Let’s dive into a real-world scenario where we need to interact with a web page using Selenium and leverage Java Streams for processing.

### Scenario:

You are tasked with writing a test that:

Opens a webpage with a table of data.

Filters rows based on certain criteria (e.g., product price, product name).

Collects the results and prints them.

Let’s assume we are testing an e-commerce website with product listings in a table. We want to:

> Filter products by a certain price range.

> Sort the filtered products alphabetically by name.

> Print the names and prices of the filtered products.

Here’s how Java Streams can be applied in this scenario:

## Example 1: Using Streams for Filtering Web Elements

```
1. Setup: Let's assume you're using Selenium to fetch the products listed in a table on a webpage.
// Import necessary libraries
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

import java.util.List;
import java.util.stream.Collectors;

public class ProductFiltering {
    public static void main(String[] args) {
        // Set up WebDriver
        WebDriver driver = new ChromeDriver();
        driver.get("http://example.com/products");

        // Get all product rows from the table
        List<WebElement> productRows = driver.findElements(By.xpath("//table[@id='product-list']//tr"));

        // Filtering, Sorting, and Collecting products using Java Streams
        List<Product> filteredProducts = productRows.stream()
            .filter(row -> {
                // Extract product price and name from each row
                String priceText = row.findElement(By.xpath(".//td[@class='price']")).getText();
                String nameText = row.findElement(By.xpath(".//td[@class='name']")).getText();

                // Parse price
                double price = Double.parseDouble(priceText.replace("$", "").trim());

                // Filter: Only include products within a price range
                return price >= 20 && price <= 100;
            })
            .map(row -> {
                // Extract product data
                String name = row.findElement(By.xpath(".//td[@class='name']")).getText();
                String priceText = row.findElement(By.xpath(".//td[@class='price']")).getText();
                double price = Double.parseDouble(priceText.replace("$", "").trim());

                // Return a Product object (you could create a Product class with name and price fields)
                return new Product(name, price);
            })
            .sorted((p1, p2) -> p1.getName().compareTo(p2.getName())) // Sorting by product name
            .collect(Collectors.toList());

        // Print out the filtered and sorted products
        filteredProducts.forEach(product -> System.out.println("Product: " + product.getName() + ", Price: $" + product.getPrice()));

        // Close the browser
        driver.quit();
    }
}

class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }
}

### Breakdown of Stream Operations:

filter(): Filters out products based on a price range.

map(): Transforms each row into a Product object that holds the name and price.

sorted(): Sorts the list of products alphabetically by name.

collect(): Collects the results into a List<Product>.

In this example, you have used the Stream API to:

Filter products based on a price range.

Map raw data into a structured object (Product).

Sort the products alphabetically by their name.

Collect the results into a list and then print them.

# Example 2: Using Streams with List of WebElements

In this example, you might want to check if any product meets a certain condition (e.g., price > 50) and then perform an action like clicking the first matching product.

```
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

import java.util.List;

public class ProductClicking {
    public static void main(String[] args) {
        // Set up WebDriver
        WebDriver driver = new ChromeDriver();
        driver.get("http://example.com/products");

        // Get all product elements (you can use any locator here, such as className, XPath, etc.)
        List<WebElement> productElements = driver.findElements(By.xpath("//div[@class='product']"));

        // Find the first product with a price greater than 50 using streams
        productElements.stream()
            .filter(product -> {
                String priceText = product.findElement(By.xpath(".//span[@class='price']")).getText();
                double price = Double.parseDouble(priceText.replace("$", "").trim());
                return price > 50; // Filter products with price > 50
            })
            .findFirst()  // Get the first product that matches the condition
            .ifPresent(product -> {
                // Click on the product
                product.click();
                System.out.println("Clicked on product with price > 50");
            });

        // Close the browser
        driver.quit();
    }
}
```
### Breakdown of Stream Operations:

filter(): Filters products with a price greater than 50.

findFirst(): Finds the first matching product and stops processing further.

ifPresent(): If the product is found, it clicks on the product.

# Advanced Stream Operations in Selenium

Here are a few advanced stream operations you might encounter in interviews or while working with Selenium:

Reduce: Useful for aggregation (e.g., calculating the total price of products).

// Calculate the total price of filtered products
double totalPrice = productRows.stream()
    .filter(row -> {
        double price = Double.parseDouble(row.findElement(By.xpath(".//td[@class='price']")).getText().replace("$", "").trim());
        return price >= 20 && price <= 100;
    })
    .mapToDouble(row -> {
        return Double.parseDouble(row.findElement(By.xpath(".//td[@class='price']")).getText().replace("$", "").trim());
    })
    .sum(); // Total sum of the filtered products


## AnyMatch / AllMatch / NoneMatch: Useful for checking if any or all elements match a certain condition.

// Check if any product has a price greater than 100
boolean hasExpensiveProduct = productRows.stream()
    .anyMatch(row -> {
        double price = Double.parseDouble(row.findElement(By.xpath(".//td[@class='price']")).getText().replace("$", "").trim());
        return price > 100;
    });
