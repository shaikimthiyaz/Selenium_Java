# What Are Java Streams? 

A Stream in Java is a **pipeline** that helps you process data (like lists, arrays, sets, etc.) in a clean, readable, and functional style.

Think of a stream like **water flowing through pipes**:

The **source** is the bucket of water (your list or array)

The **intermediate operations** are filters or mixers (steps that transform the data)

The **terminal operation** is the end where you drink or store the output (final result)

ðŸ‘‰ Streams DO NOT store data. They operate on existing collections.

ðŸ‘‰ Streams DO NOT modify the original collection.

ðŸ‘‰ Streams process elements one by one through the pipeline.

## Why Streams?

âœ” More readable

âœ” Less code

âœ” Encourages functional programming

âœ” Easy parallel processing

âœ” Helps avoid loops, temporary lists

## Types of Stream Operations

**Source** â†’ Collection, Array, I/O channels

**Intermediate operations:** Return another stream (e.g., map, filter, sorted).

**Terminal operations:** Produce a result  (e.g., collect, forEach, reduce).

**Short-circuiting operations:** Stop processing early (e.g., findFirst, anyMatch).

# terminal operator will execute only if intermediate operator returns true

# there is no life for intermediate operator if there is no terminal operator

## Important Intermediate Operations

1. filter()

Keeps only elements that match a condition
âœ” Useful for search, validation

2. map()

Transforms each element
âœ” Useful for converting objects, extracting fields

3. sorted()

Sort the elements
âœ” By natural order or custom comparator

4. distinct()

Removes duplicates

5. limit(n)

Takes first n elements

6. skip(n)

Skips first n elements

##  Terminal Operations

1. collect()

Convert back to list, set, map, etc.

2. forEach()

Perform action for each item

3. reduce()

Combine all items into one (sum, max, etc.)

4. count()

Returns the number of elements

## short-circuiting

Operations like **findFirst(), anyMatch(), allMatch(),isPresent()** 

stop processing once the answer is found


## Without Streams:

```
List<Integer> numbers = List.of(1, 2, 3, 4, 5);
List<Integer> evenNumbers = new ArrayList<>();

for (Integer n : numbers) {
    if (n % 2 == 0) {
        evenNumbers.add(n);
    }
}

System.out.println(evenNumbers); // [2, 4]
```

## With Streams (Cleaner):

```
List<Integer> numbers = List.of(1, 2, 3, 4, 5);

List<Integer> evenNumbers = numbers.stream().filter(n -> n % 2 == 0).toList();

System.out.println(evenNumbers); // [2, 4]
```

# Lambda Expressions

Lambda expression introduces the new arrow operator **`->`** into java. It divides lambda expression into two parts.

* The **left side** specifies the **parameters** required by the expression, which could also be empty if no parameters are required

* The **right side** is the lambda body which **specifies the actions** of the lambda expressions


## practical example on streams

```
package demo;

import java.util.ArrayList;

public class ExamplesOfStreams {

	public static void main(String[] args) {
//	without streams count the names starts with alphabet 's' in list
		 ArrayList<String> names = new ArrayList<>();
		 names.add("Sudha");
		 names.add("Harshi");
		 names.add("Rama");
		 names.add("Charan");
		 names.add("Subramanyam");
		 int count = 0;
		 for (String ls : names) {
			 if (ls.startsWith("S")) {
				 count++;
			 }
		 }
		 System.out.println("count is " + count);
		 
//			using streams counting name start with Aplhabet 's' in list

			long ls = names.stream().filter(n->n.startsWith("S")).count();
			System.out.println(ls);

//			passing arrays in stream and **filtering** out
			
			long s =Stream.of("Sudha","Sunil","Ram","Bheem","Sandy").filter(e->
//			{
				e.startsWith("S")
//			    return true;
//			}
			).count();
			System.out.println(s);

//			print names whose length is > than 4 in an arraylist
			names.stream().filter(e->e.length()>4).forEach(e->System.out.println(e));
			
//  		we use limit operator to limit the results
			names.stream().filter(e->e.length()>4).limit(2).forEach(e->System.out.println(e));


	}
		

}
```

## Stream Map practice

```
package demo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class StreamMap {

	public static void main(String[] args) {
		 ArrayList<String> items = new ArrayList<>();
		 items.add("pin");
		 items.add("bin");
		 items.add("tin");
		 items.add("pot");

// print the names into upperCase
		Stream.of("Sudha","Sunil","Ram","Bheem","Sandy").map(s->s.toUpperCase()).forEach(s->System.out.println(s));
		
//		print names which have first alphabet 'S' sort it and convert to upperCase
		
		List<String> people = Arrays.asList("Sudha","Sunil","Ram","Bheem","Sandy");
		people.stream().filter(p->p.startsWith("S")).sorted().map(p->p.toUpperCase()).forEach(p->System.out.println(p));

//		merging 2 lists
		Stream<String> newStream = Stream.concat(items.stream(),people.stream());
		newStream.forEach(p->System.out.println(p));
		
		}
	

}
```

## StreamCollect practice

```
package demo;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamCollect {

	public static void main(String[] args) {
		
// collect names ends with alphabet "a"
		List<String> ls=Stream.of("Sudha","Sunil","Rama","Bheem","Harshitha").filter(e->e.endsWith("a")).collect(Collectors.toList());
		System.out.println(ls);

	
	
//	print unique no. from this array i.e remove duplicates & sort it
	
	List<Integer> i = Arrays.asList(9,6,6,7,3,8,4,3,5,8,7);
	i.stream().distinct().sorted().forEach(s->System.out.println(s));

	}
}
```
