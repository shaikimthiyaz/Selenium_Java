### 1. What are Java Streams? Why are they useful in Selenium automation?
Answer:

Java Streams are a feature introduced in Java 8 that allow you to process collections in a declarative, functional style. They support operations like filter, map, sort, reduce, findFirst, etc.

## Why useful in Selenium?

To handle lists of WebElements efficiently

To avoid manual loops

Cleaner and more readable code

Faster filtering/sorting operations

Better handling of dynamic data tables, menus, dropdowns

**Example:**

```
List<WebElement> items = driver.findElements(By.tagName("li"));
List<String> names = items.stream()
        .map(WebElement::getText)
        .collect(Collectors.toList());
```

### 2. What is the difference between map() and filter() in Java Streams?
Answer:

Method	Meaning	Example Use in Selenium

map()	Transforms each element	Convert WebElement → String text

filter()	Removes unwanted elements	Keep only enabled/visible elements


**Example:**

// filter only displayed items
elements.stream()
        .filter(WebElement::isDisplayed)
        .map(WebElement::getText)
        .forEach(System.out::println);

### 3. How do you click the first element matching a condition using Streams?
Answer:

Use filter + findFirst + ifPresent:

```
driver.findElements(By.cssSelector(".product"))
      .stream()
      .filter(e -> e.getText().contains("Laptop"))
      .findFirst()
      .ifPresent(WebElement::click);
```

### 4. How can you extract prices from a table and calculate the total using Streams?
Answer:
```
double totalPrice = driver.findElements(By.xpath("//td[@class='price']"))
        .stream()
        .map(WebElement::getText)
        .map(p -> p.replace("$", ""))   // string cleaning
        .mapToDouble(Double::parseDouble)
        .sum();
```

This demonstrates map, mapToDouble, and sum (reduce operation).

### 5. What is findAny() vs findFirst()? Which one to use in Selenium?
Answer:

**findFirst()**: Returns the first element in the stream

**findAny():** Returns any element (best for parallel streams)

Selenium Usage:

Always prefer findFirst(), because DOM order matters.

### 6. Explain anyMatch(), allMatch(), and noneMatch() with examples.
Answer:
List<WebElement> products = driver.findElements(By.className("product"));


✔ anyMatch – Is any product above $100?

boolean expensive = products.stream()
        .anyMatch(e -> extractPrice(e) > 100);


✔ allMatch – Are all products visible?

boolean allVisible = products.stream()
        .allMatch(WebElement::isDisplayed);


✔ noneMatch – No product should be out of stock

boolean ok = products.stream()
        .noneMatch(e -> e.getText().contains("Out of Stock"));

### 7. What is collect() in Streams?
Answer:

collect() is a terminal operation that converts a Stream into a:

List

Set

Map

Custom collection

Example:
```
List<String> names = elements.stream()
        .map(WebElement::getText)
        .collect(Collectors.toList());
```

### 8. How do you remove duplicates using Streams?
Answer:
```
List<String> unique = elements.stream()
        .map(WebElement::getText)
        .distinct()
        .collect(Collectors.toList());
```

### 9. How do you sort WebElements using Streams?
Answer:

Sort text alphabetically:
```
List<String> sortedNames = elements.stream()
        .map(WebElement::getText)
        .sorted()
        .collect(Collectors.toList());
```

Sort by price:
```
List<Double> sortedPrices = prices.stream()
        .map(WebElement::getText)
        .map(p -> Double.parseDouble(p.replace("$", "")))
        .sorted()
        .collect(Collectors.toList());
```

### 10. What is lazy evaluation in Streams? Why important?
Answer:

Streams do not execute intermediate operations until a terminal operation (e.g., forEach, collect, findFirst) triggers execution.

Why important in Selenium?

Streams improve performance by:

Processing only required elements

Stopping early (e.g., findFirst stops at first match)

Avoiding unnecessary DOM operations

### 11. How would you extract a list of all links and click only those that contain “Contact”?
Answer:
``
driver.findElements(By.tagName("a")).stream()
        .filter(e -> e.getAttribute("href") != null)
        .filter(e -> e.getText().contains("Contact"))
        .forEach(WebElement::click);
```

### 12. How to handle dynamic tables using Streams?
Answer:
```
List<String> names = driver.findElements(By.xpath("//table/tbody/tr/td[1]"))
        .stream()
        .map(WebElement::getText)
        .collect(Collectors.toList());
```

### 13. Validate sorting on a UI table using Streams.
Answer:
```
List<String> uiList = elements.stream()
        .map(WebElement::getText)
        .collect(Collectors.toList());

List<String> sortedList = uiList.stream().sorted().collect(Collectors.toList());

Assert.assertEquals(uiList, sortedList);
```
