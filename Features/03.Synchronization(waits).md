## Synchronization

# 1. Implicit wait

>Implicit wait tells Selenium WebDriver to wait for a certain amount of time while trying to find an element before throwing a NoSuchElementException.

> It applies globally to all element searches in the driver instance.

> Implicit wait is applied **globally**. i.e., each and every element will wait

> **cons**: we may miss the bug identification, performance issues

> **syntax** :   driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));


# 2. Explicit Wait

> Explicit wait is used to target **specific element**

> Explicit wait can be achieved in 2 ways

1. **WebDriverWait** class
2. **Fluent wait**

> **syntax**:

    //here WebDriverWait is a class defined by selenium. To access the methods in a class we need to create an object
    
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(15));
        
        wait.until(ExpectedConditions.elementToBeClickable(By.id("placeOrderBtn"));

        visibilityOfElementLocated, visibilityOfAllElements etc methods are available 



# 3. Fluent Wait

> fluent wait finds the element **repeatedly at regular intervals of time** until the time out or till the object gets found

> Both WebDriverWait and FluentWait classes implements wait interface

>**Maximum Timeout**: How long Selenium should wait in total.

**Polling Interval**: How often Selenium should check for the element (e.g., every 500ms).

**Ignore Exceptions**: You can tell Selenium to ignore exceptions like NoSuchElementException while waiting.

**Custom Conditions**: Works with Function or ExpectedConditions.


> **Syntax**:

```
Wait<WebDriver> wait = new FluentWait<>(driver)
            .withTimeout(Duration.ofSeconds(30))
            .pollingEvery(Duration.ofMillis(500))
            .ignoring(NoSuchElementException.class);
```

// Use wait to find element

WebElement element = wait.until(driver -> driver.findElement(By.id("dynamicElement")));

## Real-Time Example

Imagine you’re testing a shopping site where the “Add to Cart” button appears only after product details load via AJAX:

```
driver.get("https://example-shopping.com/product/123");

// Fluent Wait setup
Wait<WebDriver> wait = new FluentWait<>(driver)
        .withTimeout(Duration.ofSeconds(20))
        .pollingEvery(Duration.ofSeconds(2))
        .ignoring(NoSuchElementException.class);

// Wait until "Add to Cart" button is visible
WebElement addToCart = wait.until(driver -> driver.findElement(By.id("add-to-cart")));
addToCart.click();
```
Here, Selenium will keep checking every 2 seconds for up to 20 seconds until the button appears. If it shows up earlier, execution continues immediately.


        // Custom function: return WebElement when visible and text contains "Ready"
        WebElement readyEl = wait.until(new Function<WebDriver, WebElement>() {
            @Override
            public WebElement apply(WebDriver d) {
                WebElement el = d.findElement(By.id("status"));
                if (el.isDisplayed() && el.getText().contains("Ready")) {
                    return el;
                }
                return null;
            }
        });
        
# 4. Thread.sleep

this is also used to wait. it is from java


## differences

| Feature                       | **Implicit Wait**                                                     | **Explicit Wait**                                                             |
| ----------------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Definition**                | Waits for a specified amount of time for elements to appear globally. | Waits for a specific condition to occur before proceeding.                    |
| **Scope**                     | Applies to **all elements** in the script.                            | Applies to **specific elements or conditions**.                               |
| **Usage**                     | Set once, works automatically for all find-element actions.           | Defined multiple times for different elements/conditions.                     |
| **Conditions Supported**      | Only waits for the presence of element in DOM.                        | Waits for multiple conditions (visibility, clickability, alerts, text, etc.). |
| **Control & Flexibility**     | Less flexible.                                                        | Highly flexible, precise, and powerful.                                       |
| **Reliability**               | May slow down the test if used wrongly; limited control.              | More stable for dynamic web elements.                                         |
| **Typical Syntax (Selenium)** | `driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);`    | `WebDriverWait(driver, 10).until(EC.visibility_of_element_located(locator));` |
| **Applies To**                | All element searches.                                                 | Only the element(s) specified in the wait condition.                          |
| **Performance**               | Can cause unexpected delays.                                          | More optimized since it waits only when needed.                               |
| **Best Use Case**             | For stable pages where elements load predictably.                     | For dynamic pages where elements load unpredictably.                          |


