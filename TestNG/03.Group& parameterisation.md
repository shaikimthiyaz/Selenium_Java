## Grouping

Grouping allows you to run **specific sets of tests** without executing the entire suite.

### example:

```
@Test(groups = {"smoke"})
public void testLogin() {
    System.out.println("Login Test");
}

@Test(groups = {"regression"})
public void testCheckout() {
    System.out.println("Checkout Test");
}
```

### run groups via xml

```
<suite name="Grouped Suite">
    <test name="Smoke Group">
        <groups>
            <run>
                <include name="smoke"/>
            </run>
        </groups>
        <classes>
            <class name="tests.LoginTests"/>
            <class name="tests.CheckoutTests"/>
        </classes>
    </test>
</suite>
```
### Real-Time Use Case:

Run smoke tests before deployment.

Run regression tests after major changes.

## Parameterization

Parameterization helps you **pass dynamic values to tests without hardcoding**

xml

```

<suite name="Parameter Suite">
    <parameter name="browser" value="chrome"/>
    <test name="Login Test">
        <classes>
            <class name="tests.LoginTests"/>
        </classes>
    </test>
</suite>
```

### java code

```

@Test
@Parameters("browser")
public void testLogin(String browser) {
    System.out.println("Running test on browser: " + browser);
}
```

**output:** Running test on browser: chrome

## DataProvider

@DataProvider is used for data-driven testing.

**example:**

```

@DataProvider(name = "loginData")
public Object[][] getData() {
    return new Object[][] {
        {"user1", "pass1"},
        {"user2", "pass2"}
    };
}

@Test(dataProvider = "loginData")
public void testLogin(String username, String password) {
    System.out.println("Login with: " + username + " / " + password);
}
```

**output**: Login with: user1 / pass1
Login with: user2 / pass2

**Real-Time Scenario:**

Use DataProvider for multiple login credentials.

Use XML parameters for environment-specific values (browser, URL).
