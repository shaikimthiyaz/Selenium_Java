# TestNG

TestNG (Test Next Generation) is a testing framework for Java inspired by JUnit but designed to be more powerful and flexible. It supports:

> Unit testing

>Integration testing

>Functional testing

>End-to-end testing

It is widely used in automation frameworks (especially Selenium) because of **its advanced features like grouping, parallel execution, and data-driven testing.**

## Why use TestNG over JUnit?

**Annotations are more powerful:** TestNG provides additional annotations like @DataProvider, @Factory, etc.

**Flexible test configuration:** Through testng.xml, you can define suites, groups, and parallel execution.

**Built-in reporting:** Generates HTML and XML reports automatically.

**Dependency management:** You can specify that one test depends on another.

**Parallel execution:** Run tests across multiple threads easily.

**Real-time Example:**

Imagine you have 100 Selenium test cases. Running them sequentially takes 2 hours. With TestNG’s parallel execution, you can run them on 5 threads and finish in ~24 minutes.

##  Key Features

>Annotations-based (no need for inheritance like JUnit)

>Supports parameterization

>Supports grouping of tests

>Built-in reporting

>Integration with build tools (Maven, Gradle)

>Supports listeners for custom behavior

# TestNG Architecture

TestNG follows a **suite-based architecture** where tests are organized into:

**Suite** → Collection of tests defined in testng.xml.

**Test** → A set of classes or methods grouped logically.

**Class** → Java class containing test methods.

**Method** → Individual test cases annotated with @Test.

### Execution Flow:

TestNG reads the testng.xml file.

Loads the suite and test configurations.

Executes test classes and methods based on annotations and priorities.

Generates reports (HTML & XML).

## Core Concepts

**Annotations:** Control test execution (@Test, @BeforeSuite, etc.).

**Groups:** Logical grouping of tests for selective execution.

**Parameters:** Pass dynamic values to tests.

**DataProviders:** Enable data-driven testing.

**Listeners:** Hook into test lifecycle for custom actions.

**Parallel Execution:** Run tests concurrently for faster execution.


### Real-Time Example: Architecture in Action

Imagine you have:

LoginTests.java

CheckoutTests.java

SearchTests.java

You create a testng.xml like this:

```

<suite name="E-Commerce Suite">
    <test name="Smoke Tests">
        <classes>
            <class name="tests.LoginTests"/>
            <class name="tests.SearchTests"/>
        </classes>
    </test>
    <test name="Regression Tests">
        <classes>
            <class name="tests.CheckoutTests"/>
        </classes>
    </test>
</suite>
```

**Execution:**

TestNG runs Smoke Tests first (Login + Search).

Then runs Regression Tests (Checkout).

Generates HTML report showing pass/fail status.


## TestNG Lifecycle/ Annotations

The TestNG lifecycle defines the **order** in which **configuration and test methods execute**. It’s crucial for understanding **setup and teardown** in automation frameworks.

Lifecycle Order:

**@BeforeSuite** → Runs once before all tests in the suite.

**@BeforeTest** → Runs before <test> tag in testng.xml.

**@BeforeClass** → Runs before the first method in the current class.

**@BeforeMethod**→ Runs before each @Test method.

**@Test** → Actual test case execution.

**@AfterMethod** → Runs after each @Test method.

**@AfterClass** → Runs after all methods in the current class.

**@AfterTest**→ Runs after <test> tag in testng.xml.

**@AfterSuite** → Runs once after all tests in the suite.


### Real-Time Example: Selenium Framework

Imagine you are testing an E-Commerce site:

@BeforeSuite → Launch browser once for the entire suite.

@BeforeTest → Navigate to base URL for all tests in a <test> block.

@BeforeClass → Initialize page objects for LoginTests.

@BeforeMethod → Log in before each test case.

@Test → Validate login functionality.

@AfterMethod → Log out after each test case.

@AfterClass → Clear page objects.

@AfterTest → Close browser for that <test> block.

@AfterSuite → Generate final report and cleanup.

### Example:

```

public class LoginTests {

    @BeforeSuite
    public void beforeSuite() {
        System.out.println("Launch Browser");
    }

    @BeforeTest
    public void beforeTest() {
        System.out.println("Navigate to Base URL");
    }

    @BeforeClass
    public void beforeClass() {
        System.out.println("Initialize Page Objects");
    }

    @BeforeMethod
    public void beforeMethod() {
        System.out.println("Login before each test");
    }

    @Test
    public void testLogin() {
        System.out.println("Executing Login Test");
    }

    @AfterMethod
    public void afterMethod() {
        System.out.println("Logout after each test");
    }

    @AfterClass
    public void afterClass() {
        System.out.println("Clear Page Objects");
    }

    @AfterTest
    public void afterTest() {
        System.out.println("Close Browser for this test block");
    }

    @AfterSuite
    public void afterSuite() {
        System.out.println("Generate Report and Cleanup");
    }
}
```

### output:

Launch Browser

Navigate to Base URL

Initialize Page Objects

Login before each test

Executing Login Test

Logout after each test

Clear Page Objects

Close Browser for this test block

Generate Report and Cleanup

 ## Advanced Features of @Test
 
The @Test annotation has powerful attributes:

**priority** → Controls execution order.

**enabled** → Enable/disable a test.

**groups** → Group tests for selective execution.

**dependsOnMethods** → Define dependencies.

**invocationCount** → Run a test multiple times.

**timeOut** → Fail if test exceeds time limit.

### Example:

```

@Test(priority = 1, groups = {"smoke"}, invocationCount = 3)
public void testSearch() {
    System.out.println("Search Test");
}
```


